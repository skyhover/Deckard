/**
 *  An ANTLRv3 capable DOT tree grammar.
 *  Rule "graph" is entry-point, which parses whole AST
 *  and returns graph object.
 *
 *	This grammar is part of CesTa project, http://cesta.sourceforge.net/
 *
 *	BSD licence
 *  Copyright (c) 2010 Tobias Smolka, BUSLAB FI MUNI 
 *
 *	All rights reserved.
 *
 *	http://buslab.org
 *
 *	Redistribution and use in source and binary forms, with or without
 *	modification, are permitted provided that the following conditions
 *	are met:
 *
 *	 1. Redistributions of source code must retain the above copyright
 *		notice, this list of conditions and the following disclaimer.
 *	 2. Redistributions in binary form must reproduce the above copyright
 *		notice, this list of conditions and the following disclaimer in the
 *		documentation and/or other materials provided with the distribution.
 *	 3. The name of the author may not be used to endorse or promote products
 *		derived from this software without specific prior written permission.
 *
 *	THIS SOFTWARE IS PROVIDED BY BUSLAB FI MUNI ('BUSLAB') ``AS IS'' 
 *	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 *	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 *	ARE DISCLAIMED. IN NO EVENT SHALL 'BUSLAB' BE LIABLE FOR ANY DIRECT, INDIRECT, 
 *	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *	LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 *	OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
 *	LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
 *	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 *	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
tree grammar DotTreeC;

options {
    language=C; // Cpp target isn't fully supported, yet.
    backtrack = true;
    // memoize = true;
    tokenVocab = DotC;
    output = AST;
    ASTLabelType = pANTLR3_BASE_TREE;
}

@treeparser::includes {
/** define Graph class */
#include <graph.h>
#include <DotCLexer.h>
#include <DotCParser.h>

Graph* pDotTreeCParserGraph(char*);
}

// global variables used in statements.. convenient way how to point to the latest graph or subgraph
@members {
static Graph* obj;
}

@postinclude {
Graph* pDotTreeCParserGraph(const char* file) {
   pANTLR3_UINT8 fName;
   pANTLR3_INPUT_STREAM input;
   pDotCLexer lxr;
   pANTLR3_COMMON_TOKEN_STREAM tstream;
   pDotCParser psr;
   DotCParser_graph_return DotCAST;
   pANTLR3_COMMON_TREE_NODE_STREAM nodes;
   pDotTreeC treePsr;
   Graph* dotGraph;

   if ( file==NULL ) {
      ANTLR3_FPRINTF(stderr, "file name can't be NULL\n");
      return NULL;
   }

   fName = (pANTLR3_UINT8)file;
   input = antlr3FileStreamNew(fName, ANTLR3_ENC_8BIT);
   if ( input == NULL ) {
      ANTLR3_FPRINTF(stderr, "Unable to open file %s due to malloc() failure1\n", (char *)fName); // ANTLR seems to mistake %s as a stringTemplate; either it's a bug in antlr or it's C target.
      return NULL;
   }

   lxr = DotCLexerNew(input);
   if ( lxr == NULL ) {
      ANTLR3_FPRINTF(stderr, "Unable to create DotC lexer due to malloc() failure1\n");
      return NULL;
   }

   tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
   if (tstream == NULL) {
      ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate DotC token stream\n");
      return NULL;
   }

   psr = DotCParserNew(tstream);  // CParserNew is generated by ANTLR3
   if (psr == NULL) {
      ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate DotC parser\n");
      return NULL;
   }

   DotCAST = psr->graph(psr);
   if ( psr->pParser->rec->getNumberOfSyntaxErrors(psr->pParser->rec) > 0) {
      ANTLR3_FPRINTF(stderr, "The DotC parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->getNumberOfSyntaxErrors(psr->pParser->rec));
      return NULL;
   }

   nodes = antlr3CommonTreeNodeStreamNewTree(DotCAST.tree, ANTLR3_SIZE_HINT); // SIZE HINT WILL SOON BE DEPRECATED!!
   treePsr = DotTreeCNew(nodes);
   dotGraph = treePsr->graph(treePsr).g;
   nodes->free(nodes); nodes = NULL;
   treePsr->free(treePsr); treePsr = NULL;

   // to close down our open objects, in the reverse order we created them
   psr->free(psr); psr = NULL;
   tstream->free(tstream); tstream = NULL;
   lxr->free(lxr); lxr = NULL;
   input->close(input); input = NULL;

   return dotGraph;
}
}

graph returns [Graph* g]
    @init {
        obj = new Graph();
    }
    :
        ^(GRAPH_ROOT
            graphModifier
            ID? {
            	if ($ID!=NULL) obj->setGraphName((const char*)($ID.text->chars));
            }
            stmt_list
        ) {$g = obj;}
    ;

graphModifier
    :
        (STRICT)? (GRAPH | DIGRAPH)
    ;

stmt_list
    :
        ^(STMT_LIST stmt+)
    ;

stmt
    :
        attr_stmt |
    	subgraph |
    	^(ATTR n=ID EQUAL v=ID) |
    	edge_stmt |
    	node_stmt
    ;

attr_stmt
    :
        ^( GRAPH a=attr_list {
        	obj->mergeGraphAttributes($a.attributes);
        	delete $a.attributes;
           }
          )
    |   ^( NODE a=attr_list )
    |   ^( EDGE a=attr_list )
    ;

attr_list returns [std::map<int, std::string>* attributes]
    @init {
    	int id = -1;
        $attributes = new std::map<int, std::string>();
    }
    :
    	^(ATTR_LIST (attr {
    		id=obj->getOrAddAttributeID($attr.name);
    		$attributes->insert(std::make_pair(id, $attr.value));
    	} )*)
    ;

attr returns [std::string name, std::string value]
    :
        ^(ATTR n=ID (EQUAL v=ID)?) {
        	$name = (const char*)($n.text->chars);
        	$value=(const char*)($v.text->chars);
        }
    ;

edge_stmt
    @init {
        GraphNode* lhs = NULL;
        GraphNode* rhs = NULL;
    }
    :
       ^(EDGE_STMT 
           n=node_id
           {
                lhs = obj->getNode($n.id);
                if (lhs==NULL) {
                    lhs = new GraphNode($n.id);
                }
           }
           edgeRHS {
           	rhs = $edgeRHS.rhs;
           	if ( rhs!=NULL )
           	    obj->addEdge(lhs, rhs);
           }
           attr_list? // ignore edge attribute for now
       )
    |
        ^(EDGE_STMT 
            s=subgraph // ignore subgraphs for now
            edgeRHS
            attr_list?
        )
        
    ;

edgeRHS returns [GraphNode* rhs]
    :
        ^(EDGEOP n=node_id
            {
                GraphNode* node = obj->getNode($n.id);
                if (node==NULL) {
                    node=new GraphNode($n.id);
                }
                $rhs = node;
            } (edgeRHS)?) // ignore more complex graphs
    |   ^(EDGEOP subgraph // ignore subgraphs for now
            {
                $rhs = NULL;
            }
            (edgeRHS)?
        )
    ;

node_stmt
    :
        ^(NODE_STMT n=node_id a=attr_list? {
            GraphNode* node = obj->getNode($n.id);
            if ( node==NULL ) {
                node=new GraphNode($n.id);
                obj->addNode(node);
            }
            node->mergeAttributes($a.attributes);
            delete $a.attributes;
        })
    ;

node_id returns [std::string id, std::string idport]
    :
        ^(ident=ID p=port?) { // ignore port for now
        	$id=(const char*)($ident.text->chars);
        	if($p.tree!=NULL)
        		$idport=(const char*)($p.text->chars);
        	else
        		$idport="";
        }
    ;

port
    :
    	ID (VALIDSTR)? |
    	VALIDSTR
    ;

subgraph
    :
    	^(SUBGRAPH_ROOT
            ID?
            stmt_list
          )
      |
          ^(SUBGRAPH_ROOT ID)
    ;
